// ======================================================
// PLAYER OBJECT AND ACTIONS
// ======================================================
const player = {
    x: MAP_WIDTH / 2, y: MAP_HEIGHT / 2,
    width: PLAYER_SPRITE_SIZE.width, height: PLAYER_SPRITE_SIZE.height,
    speed: 150, // Pixels per REAL second (Player speed not affected by timeScale)
    inventory: new Inventory(INVENTORY_SLOTS), money: STARTING_PLAYER_GOLD,
    targetNpc: null, element: null,

    init: () => { player.element = document.createElement('div'); player.element.id = 'player'; player.element.classList.add('player'); player.element.style.width = `${player.width}px`; player.element.style.height = `${player.height}px`; document.getElementById('gameContainer').appendChild(player.element); Object.entries(STARTING_PLAYER_ITEMS).forEach(([itemId, quantity]) => player.inventory.addItem(itemId, quantity)); updatePlayerInventoryUI(); document.getElementById('playerGold').textContent = formatGold(player.money); player.draw(); },

    move: (dx, dy, realDeltaTime) => {
        const moveAmount = player.speed * realDeltaTime;
        const newX = player.x + dx * moveAmount; const newY = player.y + dy * moveAmount;
        const minX = player.width / 2; const minY = player.height / 2;
        const maxX = MAP_WIDTH - player.width / 2; const maxY = MAP_HEIGHT - player.height / 2;
        player.x = clamp(newX, minX, maxX); player.y = clamp(newY, minY, maxY);
        player.draw();
    },

    interact: () => { const interactionRange = NPC_TRADE_DISTANCE + 10; let closestInteractableNpc = null; let minDistSq = interactionRange * interactionRange; npcs.forEach(npc => { const dx = player.x - npc.x; const dy = player.y - npc.y; const distSq = dx * dx + dy * dy; if (distSq < minDistSq) { const canInteract = [NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES, NPC_STATE.WAITING_FOR_TRADE].includes(npc.state); if (canInteract) { minDistSq = distSq; closestInteractableNpc = npc; } } }); if (closestInteractableNpc) { if(player.targetNpc?.id !== closestInteractableNpc.id){ openNpcInteractionPanel(closestInteractableNpc); } } else { if(player.targetNpc) { closeNpcInteractionPanel(); } } },

    buyItem: (npc, itemId, quantity) => { if (!npc || !ITEMS[itemId] || !player.targetNpc || npc.id !== player.targetNpc.id) return false; if (calculateDistance(player, npc) > 50) { closeNpcInteractionPanel(); return false; } if (isNaN(quantity) || quantity < 1) { alert("Please enter a valid quantity."); return false;} quantity = Math.floor(quantity); const price = calculateSellPrice(npc, itemId); const totalCost = price * quantity; const npcStock = npc.inventory.getItemCount(itemId); if (quantity > npcStock) { alert(`NPC only has ${npcStock} ${ITEMS[itemId].name}.`); return false; } if (player.money < totalCost) { alert(`Not enough gold (Need ${totalCost}g).`); updateNpcInteractionPanel(npc); return false; } const slotsNeeded = player.inventory.hasItem(itemId) ? 0 : 1; const currentSlots = player.inventory.getTotalSlotsUsed(); if (currentSlots + slotsNeeded > player.inventory.maxSlots && !player.inventory.hasItem(itemId)) { alert("Not enough space in your inventory for a new item type."); return false; } const removed = npc.inventory.removeItem(itemId, quantity); if (removed === quantity) { const added = player.inventory.addItem(itemId, quantity); if (added === quantity) { player.money -= totalCost; npc.money += totalCost; if (npc.occupation?.dialogue?.buy) { showDialogue(npc.name, getRandomDialogue(npc.occupation.dialogue.buy), 3000); } updatePlayerInventoryUI(); updateNpcInteractionPanel(npc); updatePlayerGoldUI(); return true; } else { npc.inventory.addItem(itemId, quantity); alert(`Could only fit ${added} in your inventory.`); updateNpcInteractionPanel(npc); return false; } } else { console.error(`CRITICAL: ${npc.name} failed to remove ${itemId}`); updateNpcInteractionPanel(npc); return false; } },

    sellItem: (npc, itemId, quantity) => { if (!npc || !ITEMS[itemId] || !player.targetNpc || npc.id !== player.targetNpc.id) return false; if (calculateDistance(player, npc) > 50) { closeNpcInteractionPanel(); return false; } if (isNaN(quantity) || quantity < 1) { alert("Please enter a valid quantity."); return false;} quantity = Math.floor(quantity); if (!player.inventory.hasItem(itemId, quantity)) { alert(`You don't have ${quantity} ${ITEMS[itemId].name}.`); return false; } const price = calculateBuyPrice(npc, itemId); const totalValue = price * quantity; const npcHasSlots = npc.inventory.getTotalSlotsUsed() < npc.inventory.maxSlots; const npcStackSpace = npc.inventory.items[itemId] ? npc.inventory.maxStackSize[itemId] - npc.inventory.getItemCount(itemId) : npc.inventory.maxStackSize[itemId]; const npcCanTake = npcHasSlots || (npc.inventory.hasItem(itemId) && quantity <= npcStackSpace); if (price <= 0) { alert("NPC is not buying this item."); updateNpcInteractionPanel(npc); return false; } if (npc.money < totalValue) { alert(`NPC cannot afford this (Needs ${totalValue}g).`); updateNpcInteractionPanel(npc); return false; } if (!npcCanTake) { alert("NPC inventory is full."); updateNpcInteractionPanel(npc); return false; } const removed = player.inventory.removeItem(itemId, quantity); if (removed === quantity) { const added = npc.inventory.addItem(itemId, quantity); if (added === quantity) { player.money += totalValue; npc.money -= totalValue; if (npc.occupation?.dialogue?.sell) { showDialogue(npc.name, getRandomDialogue(npc.occupation.dialogue.sell), 3000); } updatePlayerInventoryUI(); updateNpcInteractionPanel(npc); updatePlayerGoldUI(); return true; } else { player.inventory.addItem(itemId, quantity); alert(`NPC could only take ${added}. Sale failed.`); updateNpcInteractionPanel(npc); return false; } } else { console.error(`CRITICAL: Player failed to remove ${itemId}`); updatePlayerInventoryUI(); return false; } },

    draw: () => { if (!player.element) return; const drawX = player.x - player.width / 2; const drawY = player.y - player.height / 2; player.element.style.left = `${drawX}px`; player.element.style.top = `${drawY}px`; const charSpritePath = USE_SPRITES ? CHAR_SPRITES['player'] : null; if (charSpritePath && loadedCharSprites['player']?.complete && loadedCharSprites['player']?.naturalHeight !== 0) { player.element.style.backgroundImage = `url('${ASSET_BASE_PATH + charSpritePath}')`; player.element.style.backgroundColor = 'transparent'; player.element.style.border = 'none'; } else { player.element.style.backgroundImage = 'none'; player.element.style.backgroundColor = 'blue'; player.element.style.border = '1px solid navy'; } },
};