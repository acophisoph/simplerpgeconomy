// ======================================================
// NPC CLASS AND BEHAVIOR
// ======================================================

let npcNextId = 0;
const npcs = [];

class Npc {
    constructor(name, occupationId, startX, startY) {
        this.id = npcNextId++;
        this.name = name;
        this.occupationId = occupationId;
        this.occupation = OCCUPATIONS[occupationId];
        if (!this.occupation) { console.error(`FATAL: Invalid occupation ID "${occupationId}" for NPC "${name}".`); return; }
        this.workLocation = { ...(this.occupation.workLocation || { x: 100, y: 100 }) };
        this.x = startX ?? this.workLocation.x;
        this.y = startY ?? this.workLocation.y;
        this.inventory = new Inventory();
        this.money = STARTING_NPC_GOLD;
        this.state = NPC_STATE.IDLE;
        this.stateTimer = 0; // Game seconds spent in current state
        this.targetLocation = null;
        this.targetNpc = null;
        this.tradeDetails = null;
        this.workDeadline = 0; // Game time when current work finishes
        this.consumeNeedDeadline = gameTime + getRandomInt(0, NPC_CONSUME_NEED_INTERVAL);
        this.nextTradeDecisionTime = gameTime + getRandomInt(Math.floor(500 / GAME_SECONDS_PER_REAL_SECOND), NPC_TRADE_DECISION_INTERVAL);
        this.currentRecipe = null;
        this.recipeProgress = 0; // Accumulated game seconds
        this.speed = NPC_MOVE_SPEED; // Base speed in pixels/real second
        this.initializeInventory();
        npcs.push(this);
    }

    initializeInventory() { for (const [itemId, desiredAmount] of Object.entries(this.occupation.desiredStock || {})) { if (desiredAmount >= 1 && ITEMS[itemId]) { const stackSize = ITEMS[itemId].stackSize || 1; const giveAmount = Math.min(desiredAmount, stackSize); if (giveAmount > 0) { this.inventory.addItem(itemId, Math.max(1, Math.ceil(giveAmount / 2))); } } } if (this.occupation.needs) { for(const [itemId, needRate] of Object.entries(this.occupation.needs)){ if(needRate > 0 && ITEMS[itemId]?.durability && this.inventory.getItemCount(itemId) < 1){ this.inventory.addItem(itemId, 1); } } } const foodNeed = this.occupation.needs?.['bread'] || this.occupation.needs?.['meat']; if (foodNeed && this.inventory.getItemCount('bread') < 2 && this.inventory.getItemCount('meat') < 2) { this.inventory.addItem('bread', getRandomInt(1, 3)); } }

    setState(newState) { if (this.state !== newState && Object.values(NPC_STATE).includes(newState)) { this.state = newState; this.stateTimer = 0; if ([NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES].includes(newState)) { this.targetLocation = null; this.targetNpc = null; this.tradeDetails = null; } if (newState === NPC_STATE.WORKING) { this.workDeadline = 0; this.recipeProgress = 0; this.currentRecipe = null; } } else if (!Object.values(NPC_STATE).includes(newState)) { console.warn(`${this.name} tried to enter invalid state: ${newState}`); } }

    update(realDeltaTime, currentTimeScale) {
        if (!this.occupation) return;
        const gameDeltaTime = realDeltaTime * currentTimeScale * GAME_SECONDS_PER_REAL_SECOND;
        this.stateTimer += gameDeltaTime;

        switch (this.state) {
            case NPC_STATE.IDLE: this.updateIdle(gameDeltaTime); break;
            case NPC_STATE.WORKING: this.updateWorking(gameDeltaTime); break;
            case NPC_STATE.NEED_RESOURCES: this.updateNeedResources(gameDeltaTime); break;
            case NPC_STATE.MOVING_TO_TRADE: this.updateMovingToTrade(realDeltaTime, currentTimeScale); break; // Pass scale
            case NPC_STATE.WAITING_FOR_TRADE: this.updateWaitingForTrade(gameDeltaTime); break;
            case NPC_STATE.EXECUTING_TRADE: break;
            case NPC_STATE.MOVING_TO_WORK: this.updateMovingToWork(realDeltaTime, currentTimeScale); break; // Pass scale
            default: this.setState(NPC_STATE.IDLE); break;
        }
        this.checkConsumptionNeeds(); this.checkTradeDecision();
    }

    updateIdle(gameDeltaTime) { if (this.canWork()) { this.setState(NPC_STATE.WORKING); } else if (!this.hasProductionNeeds(true)) { this.setState(NPC_STATE.NEED_RESOURCES); } }

    updateWorking(gameDeltaTime) {
        if (!this.canWork()) { this.setState(NPC_STATE.NEED_RESOURCES); this.workDeadline = 0; this.recipeProgress = 0; this.currentRecipe = null; return; }
        if (this.workDeadline <= 0) {
             if (this.occupation.produces && Object.keys(this.occupation.produces).length > 0) { this.workDeadline = gameTime + this.occupation.productionTime; }
             else if (this.occupation.recipes) { this.chooseRecipeToCraft(); if (this.currentRecipe) { this.recipeProgress = 0; this.workDeadline = gameTime + (this.occupation.recipes[this.currentRecipe]?.time || 10 * GAME_SECONDS_PER_REAL_SECOND); } else { this.setState(NPC_STATE.IDLE); return; } }
             else { this.setState(NPC_STATE.IDLE); return; }
        }
        if (gameTime >= this.workDeadline) {
            if (this.occupation.produces) { this.completeProductionCycle(); }
             else if (this.currentRecipe) { this.completeCraftingCycle(); }
             this.workDeadline = 0;
             if (this.state === NPC_STATE.WORKING) { this.currentRecipe = null; this.setState(NPC_STATE.IDLE); }
        } else if (this.currentRecipe) { this.recipeProgress += gameDeltaTime; }
    }

    updateNeedResources(gameDeltaTime) { if (this.canWork()) { this.setState(NPC_STATE.IDLE); } else if (this.stateTimer > NPC_TRADE_DECISION_INTERVAL * 5) { this.scheduleNextTradeDecision(true); this.stateTimer = 0; } }

    updateMovingToTrade(realDeltaTime, currentTimeScale) { if (!this.targetLocation || !this.targetNpc || !this.tradeDetails) { this.setState(NPC_STATE.MOVING_TO_WORK); this.targetLocation = this.workLocation; return; } const targetStillValid = npcs.includes(this.targetNpc) && calculateDistance(this.targetNpc, this.targetNpc.workLocation) < NPC_TRADE_DISTANCE * 2; if (!targetStillValid) { this.setState(NPC_STATE.MOVING_TO_WORK); this.targetLocation = this.workLocation; return; } const arrived = this.moveTowards(this.targetLocation, realDeltaTime, currentTimeScale); if (arrived) { this.setState(NPC_STATE.WAITING_FOR_TRADE); } }

    updateWaitingForTrade(gameDeltaTime) { if (!this.targetNpc || !this.tradeDetails) { this.setState(NPC_STATE.MOVING_TO_WORK); this.targetLocation = this.workLocation; return; } const targetStillValid = npcs.includes(this.targetNpc); const targetNearby = targetStillValid && calculateDistance(this, this.targetNpc) <= NPC_TRADE_DISTANCE * 1.2; const targetAvailable = targetStillValid && [NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES].includes(this.targetNpc.state); const waitDuration = NPC_WAIT_BEFORE_TRADE + getRandomInt(Math.floor(-500 / GAME_SECONDS_PER_REAL_SECOND), Math.floor(500 / GAME_SECONDS_PER_REAL_SECOND)); if (targetStillValid && targetNearby && targetAvailable && this.stateTimer >= 5) { const success = this.attemptExecuteTrade(); this.setState(NPC_STATE.MOVING_TO_WORK); this.targetLocation = this.workLocation; } else if (this.stateTimer >= waitDuration * 1.5 || !targetStillValid) { this.setState(NPC_STATE.MOVING_TO_WORK); this.targetLocation = this.workLocation; } }

    updateMovingToWork(realDeltaTime, currentTimeScale) { if (!this.targetLocation || this.targetLocation.x !== this.workLocation.x || this.targetLocation.y !== this.workLocation.y) { this.targetLocation = this.workLocation; } const arrived = this.moveTowards(this.targetLocation, realDeltaTime, currentTimeScale); if (arrived) { this.x = this.workLocation.x; this.y = this.workLocation.y; this.setState(NPC_STATE.IDLE); } }

    checkConsumptionNeeds() { if (gameTime >= this.consumeNeedDeadline) { const basicNeedsIds = ['bread', 'meat', 'basic_potion']; for (const needId of basicNeedsIds) { const desired = this.occupation.desiredStock?.[needId]; const needRate = this.occupation.needs?.[needId]; if ((desired !== undefined && desired > 0) || (needRate !== undefined && needRate > 0)) { if (this.inventory.getItemCount(needId) < (desired || 1)) { const effectiveRate = needRate || 0.05; const consumptionChance = effectiveRate * (NPC_CONSUME_NEED_INTERVAL / 1000) / 5; if (Math.random() < consumptionChance) { if (this.inventory.hasItem(needId, 1)) { this.inventory.removeItem(needId, 1); break; } } } } } const variation = getRandomInt(Math.floor(-1 * 60), Math.floor(1 * 60)); this.consumeNeedDeadline = gameTime + NPC_CONSUME_NEED_INTERVAL + variation; } }

    checkTradeDecision() { const isAtWorkLocation = calculateDistance(this, this.workLocation) < 5; const canDecideTrade = [NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES].includes(this.state); if (isAtWorkLocation && canDecideTrade && gameTime >= this.nextTradeDecisionTime) { this.evaluateTradeNeeds(); this.scheduleNextTradeDecision(); } }

    moveTowards(target, realDeltaTime, currentTimeScale) { if (!target) return false; const dx = target.x - this.x; const dy = target.y - this.y; const distance = Math.sqrt(dx * dx + dy * dy); const effectiveSpeed = this.speed * currentTimeScale; const moveAmount = effectiveSpeed * realDeltaTime; if (distance <= moveAmount || distance < 1) { this.x = target.x; this.y = target.y; return true; } else { this.x += (dx / distance) * moveAmount; this.y += (dy / distance) * moveAmount; return false; } }

    scheduleNextTradeDecision(forceImmediate = false) { if (forceImmediate) { this.nextTradeDecisionTime = gameTime; } else { const variation = getRandomInt(Math.floor(-2 * 60), Math.floor(2 * 60)); this.nextTradeDecisionTime = gameTime + NPC_TRADE_DECISION_INTERVAL + variation; } }

    // --- (Keep canWork, hasSpaceForOutput, hasProductionNeeds, hasRecipeNeeds as in V4) ---
    canWork() { const hasNeeds = this.hasProductionNeeds(true); const hasSpace = this.hasSpaceForOutput(); return hasNeeds && hasSpace; }
    hasSpaceForOutput() { if (this.inventory.getTotalSlotsUsed() < this.inventory.maxSlots) { return true; } let outputItemId = null; let outputAmount = 1; if (this.occupation.produces && Object.keys(this.occupation.produces).length > 0) { outputItemId = Object.keys(this.occupation.produces)[0]; outputAmount = this.occupation.produces[outputItemId]; } else if (this.currentRecipe && this.occupation.recipes?.[this.currentRecipe]) { outputItemId = this.currentRecipe; outputAmount = this.occupation.recipes[outputItemId].output; } else if (this.occupation.recipes){ return true; } if (!outputItemId) return true; const existingItem = this.inventory.items[outputItemId]; if (existingItem) { const currentQty = existingItem.quantity; const stackSize = this.inventory.maxStackSize[outputItemId]; if (currentQty + outputAmount <= stackSize) { return true; } } return false; }
    hasProductionNeeds(checkToolsAndConsumables = true) { if (this.occupation.needs) { for (const [itemId, requiredAmount] of Object.entries(this.occupation.needs)) { if (requiredAmount <= 0) continue; if (ITEMS[itemId]?.durability) { if (checkToolsAndConsumables && this.inventory.getItemCount(itemId) < 1) { return false; } } else { if (checkToolsAndConsumables && this.inventory.getItemCount(itemId) < requiredAmount) { return false; } } } } if (this.currentRecipe && this.occupation.recipes && this.state === NPC_STATE.WORKING) { if (!this.hasRecipeNeeds(this.currentRecipe)) { return false; } } return true; }
    hasRecipeNeeds(recipeId) { const recipe = this.occupation.recipes?.[recipeId]; if (!recipe) return false; for (const [itemId, requiredAmount] of Object.entries(recipe.needs)) { if (this.inventory.getItemCount(itemId) < requiredAmount) { return false; } } if (this.occupation.needs) { for (const [itemId, requiredAmount] of Object.entries(this.occupation.needs)) { if (!ITEMS[itemId]?.durability && requiredAmount > 0) { if (this.inventory.getItemCount(itemId) < 1){ return false; } } } } return true; }

    // --- (Keep completeProductionCycle, chooseRecipeToCraft, completeCraftingCycle as in V4) ---
    completeProductionCycle() { if (this.occupation.needs) { for (const [itemId, requiredAmount] of Object.entries(this.occupation.needs)) { if (requiredAmount > 0) { if (ITEMS[itemId]?.durability) { if (!this.inventory.useTool(itemId)) { this.setState(NPC_STATE.NEED_RESOURCES); return; } } else { this.inventory.removeItem(itemId, requiredAmount); } } } } if (this.occupation.produces) { for (const [itemId, producedAmount] of Object.entries(this.occupation.produces)) { this.inventory.addItem(itemId, producedAmount); } } }
    chooseRecipeToCraft() { let bestRecipe = null; let highestPriority = -1; for (const [recipeId, recipeInfo] of Object.entries(this.occupation.recipes || {})) { const outputItemId = recipeId; const currentStock = this.inventory.getItemCount(outputItemId); const desiredStock = this.occupation.desiredStock?.[outputItemId] || 1; if (currentStock < desiredStock) { if(this.hasRecipeNeeds(recipeId)){ const priority = (desiredStock - currentStock) / (desiredStock + 0.1); if (priority > highestPriority) { highestPriority = priority; bestRecipe = recipeId; } } } } this.currentRecipe = bestRecipe; }
    completeCraftingCycle() { if (!this.currentRecipe || !this.occupation.recipes?.[this.currentRecipe]) return; const recipeInfo = this.occupation.recipes[this.currentRecipe]; const recipeTime = (recipeInfo.time || 10 * GAME_SECONDS_PER_REAL_SECOND); for (const [itemId, requiredAmount] of Object.entries(recipeInfo.needs)) { this.inventory.removeItem(itemId, requiredAmount); } if (this.occupation.needs) { const cycleTime = this.occupation.productionTime || recipeTime; const consumptionScale = Math.min(1, recipeTime / cycleTime); for (const [itemId, requiredAmount] of Object.entries(this.occupation.needs)) { if (!ITEMS[itemId]?.durability && requiredAmount > 0) { this.inventory.removeItem(itemId, requiredAmount * consumptionScale); } } } this.inventory.addItem(this.currentRecipe, recipeInfo.output); }

    // --- (Keep evaluateTradeNeeds, getMissingNeeds, getExcessInventory, findBestSeller, findBestBuyer, attemptExecuteTrade as in V4) ---
    evaluateTradeNeeds() { let bestTradeFound = null; let bestScore = -Infinity; const missingProdNeeds = this.getMissingNeeds(true); const missingBasicNeeds = this.getMissingNeeds(false); const allMissingNeeds = [...new Set([...missingProdNeeds, ...missingBasicNeeds])]; for (const itemId of allMissingNeeds) { const { targetNpc, price } = this.findBestSeller(itemId); if (targetNpc && price > 0 && this.money >= price) { const isProdNeed = missingProdNeeds.includes(itemId); const currentStock = this.inventory.getItemCount(itemId); const isTool = ITEMS[itemId]?.durability; const needRate = this.occupation.needs?.[itemId] || 0; const requiredNow = (isTool && currentStock < 1 && needRate > 0) || (!isTool && needRate > 0 && currentStock < needRate); let urgencyScore = requiredNow ? 100 : (isProdNeed ? 50 : 10); const desired = this.occupation.desiredStock?.[itemId] || (isTool ? 1 : 5); const deficitFactor = Math.max(0, desired - currentStock); const priceFactor = (ITEMS[itemId].basePrice + 1) / (price + 1); const score = urgencyScore * priceFactor + deficitFactor; if (score > bestScore) { bestScore = score; bestTradeFound = { type: 'buy', itemId, targetNpc, price, quantity: 1, score }; } } } const inventoryFullness = this.inventory.getTotalSlotsUsed() / this.inventory.maxSlots; const shouldConsiderSelling = !bestTradeFound || bestScore < 20 || inventoryFullness > 0.9; if (shouldConsiderSelling) { const itemsToSell = this.getExcessInventory(); for (const itemId of itemsToSell) { const { targetNpc, price } = this.findBestBuyer(itemId); if (targetNpc && price > 0) { const currentStock = this.inventory.getItemCount(itemId); const desired = this.occupation.desiredStock?.[itemId] || 5; const score = 10 + (currentStock - desired) + (inventoryFullness * 20); if (score > bestScore) { bestScore = score; bestTradeFound = { type: 'sell', itemId, targetNpc, price, quantity: 1, score }; } } } } if (bestTradeFound) { this.targetNpc = bestTradeFound.targetNpc; this.targetLocation = { ...(this.targetNpc.workLocation || { x: targetNpc.x, y: targetNpc.y }) }; this.tradeDetails = { ...bestTradeFound }; this.setState(NPC_STATE.MOVING_TO_TRADE); } }
    getMissingNeeds(checkProduction = true) { const missing = new Set(); const checkItemNeed = (itemId) => { const current = this.inventory.getItemCount(itemId); const desired = this.occupation.desiredStock?.[itemId]; const isTool = ITEMS[itemId]?.durability; const needRate = this.occupation.needs?.[itemId] || 0; let requiredLevel = 0; if (isTool && needRate > 0) requiredLevel = 1; else if (needRate > 0) requiredLevel = needRate; const targetLevel = Math.max(requiredLevel, desired || 0); if (current < targetLevel && targetLevel > 0) { const usesItem = needRate > 0 || this.occupation.buyPrefs?.includes(itemId) || (this.occupation.recipes && Object.values(this.occupation.recipes).some(r => r.needs[itemId])); if (usesItem) { missing.add(itemId); } } }; if (checkProduction) { Object.keys(this.occupation.needs || {}).forEach(checkItemNeed); if (this.occupation.recipes) { for (const [recipeId, recipeInfo] of Object.entries(this.occupation.recipes)) { if (this.inventory.getItemCount(recipeId) < (this.occupation.desiredStock?.[recipeId] || 1)) { Object.keys(recipeInfo.needs).forEach(checkItemNeed); } } } } else { const basicNeedsIds = ['bread', 'meat', 'basic_potion']; basicNeedsIds.forEach(id => { if ((this.occupation.desiredStock?.[id] || 0) > 0 || (this.occupation.needs?.[id] || 0) > 0 || this.occupation.buyPrefs?.includes(id)) { checkItemNeed(id); } }); } return Array.from(missing); }
    getExcessInventory() { const excess = new Set(); const sellableItems = new Set([...(this.occupation.sellPrefs || []), ...Object.keys(this.occupation.produces || {}), ...Object.keys(this.occupation.recipes || {}) ]); const isInventoryNearFull = this.inventory.getTotalSlotsUsed() >= this.inventory.maxSlots - 2; for (const itemId of sellableItems) { const current = this.inventory.getItemCount(itemId); if (current <= 0) continue; const desired = this.occupation.desiredStock?.[itemId]; const isTool = ITEMS[itemId]?.durability; let excessThreshold = 0; if (desired !== undefined) { excessThreshold = desired + (isTool ? 0 : 1); } else { excessThreshold = isTool ? 1 : 5; } if (current > excessThreshold || (isInventoryNearFull && current > 0)) { excess.add(itemId); } } return Array.from(excess); }
    findBestSeller(itemId) { let bestPrice = Infinity; let bestSeller = null; npcs.forEach(otherNpc => { if (otherNpc === this || [NPC_STATE.MOVING_TO_TRADE, NPC_STATE.MOVING_TO_WORK].includes(otherNpc.state)) return; const isAtWork = calculateDistance(otherNpc, otherNpc.workLocation) < 10; const canTradeNow = isAtWork && [NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES].includes(otherNpc.state); if (canTradeNow && otherNpc.inventory.hasItem(itemId)) { const sellerOccupation = otherNpc.occupation; const wantsToSell = sellerOccupation.sellPrefs?.includes(itemId) || (sellerOccupation.produces?.[itemId]) || (sellerOccupation.recipes?.[itemId]); const sellerHasExcess = otherNpc.inventory.getItemCount(itemId) > (sellerOccupation.desiredStock?.[itemId] || 5) * 1.5; if(wantsToSell || sellerHasExcess) { const price = calculateSellPrice(otherNpc, itemId); if (price > 0 && price < bestPrice && this.money >= price) { bestPrice = price; bestSeller = otherNpc; } } } }); return { targetNpc: bestSeller, price: bestPrice === Infinity ? 0 : bestPrice }; }
    findBestBuyer(itemId) { let bestPrice = 0; let bestBuyer = null; npcs.forEach(otherNpc => { if (otherNpc === this || [NPC_STATE.MOVING_TO_TRADE, NPC_STATE.MOVING_TO_WORK].includes(otherNpc.state)) return; const isAtWork = calculateDistance(otherNpc, otherNpc.workLocation) < 10; const canTradeNow = isAtWork && [NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES].includes(otherNpc.state); if(canTradeNow){ const buyerOccupation = otherNpc.occupation; const wantsToBuy = buyerOccupation.buyPrefs?.includes(itemId) || (buyerOccupation.needs?.[itemId]) || (buyerOccupation.recipes && Object.values(buyerOccupation.recipes).some(r => r.needs[itemId])); if(wantsToBuy){ const price = calculateBuyPrice(otherNpc, itemId); const buyerHasSpace = otherNpc.inventory.getTotalSlotsUsed() < otherNpc.inventory.maxSlots || otherNpc.inventory.hasItem(itemId); if (price > bestPrice && otherNpc.money >= price && buyerHasSpace) { bestPrice = price; bestBuyer = otherNpc; } } } }); return { targetNpc: bestBuyer, price: bestPrice }; }
    attemptExecuteTrade() { if (!this.targetNpc || !this.tradeDetails) return false; const target = this.targetNpc; const { type, itemId, quantity } = this.tradeDetails; const targetPresent = npcs.includes(target) && calculateDistance(this, target) <= NPC_TRADE_DISTANCE; const targetAvailableState = targetPresent && [NPC_STATE.IDLE, NPC_STATE.WORKING, NPC_STATE.NEED_RESOURCES].includes(target.state); if (!targetAvailableState) { console.log(`Trade ABORTED - ${target?.name || '?'} unavailable.`); return false; } const previousState = this.state; this.setState(NPC_STATE.EXECUTING_TRADE); let success = false; if (type === 'buy') { const currentSellPrice = calculateSellPrice(target, itemId); if (this.money >= currentSellPrice && target.inventory.hasItem(itemId, quantity)) { const removed = target.inventory.removeItem(itemId, quantity); if (removed === quantity) { const added = this.inventory.addItem(itemId, quantity); if (added === quantity) { this.money -= currentSellPrice; target.money += currentSellPrice; success = true; } else { target.inventory.addItem(itemId, quantity); } } } } else if (type === 'sell') { const currentBuyPrice = calculateBuyPrice(target, itemId); const targetHasSpace = target.inventory.getTotalSlotsUsed() < target.inventory.maxSlots || target.inventory.hasItem(itemId); if (currentBuyPrice > 0 && target.money >= currentBuyPrice && this.inventory.hasItem(itemId, quantity) && targetHasSpace) { const removed = this.inventory.removeItem(itemId, quantity); if (removed === quantity) { const added = target.inventory.addItem(itemId, quantity); if (added === quantity) { this.money += currentBuyPrice; target.money -= currentBuyPrice; success = true; } else { this.inventory.addItem(itemId, quantity); } } } } this.setState(previousState); return success; }

    draw(element) { /* (Keep draw logic using NPC_SPRITE_SIZE) */ if (!element) return; const drawX = this.x - NPC_SPRITE_SIZE.width / 2; const drawY = this.y - NPC_SPRITE_SIZE.height / 2; element.style.left = `${drawX}px`; element.style.top = `${drawY}px`; element.style.width = `${NPC_SPRITE_SIZE.width}px`; element.style.height = `${NPC_SPRITE_SIZE.height}px`; const charSpritePath = USE_SPRITES ? CHAR_SPRITES[this.occupationId] : null; element.className = 'npc'; if (charSpritePath && loadedCharSprites[this.occupationId]?.complete && loadedCharSprites[this.occupationId]?.naturalHeight !== 0) { element.style.backgroundImage = `url('${ASSET_BASE_PATH + charSpritePath}')`; element.style.backgroundColor = 'transparent'; element.style.border = 'none'; element.textContent = ''; } else { element.style.backgroundImage = 'none'; element.classList.add(`${this.occupationId}-color`); element.style.border = '1px solid black'; element.textContent = this.occupation.name.substring(0,1); } let stateSymbol = ''; switch(this.state) { case NPC_STATE.NEED_RESOURCES: stateSymbol = '!'; break; case NPC_STATE.MOVING_TO_TRADE: stateSymbol = '>'; break; case NPC_STATE.WAITING_FOR_TRADE: stateSymbol = '?'; break; case NPC_STATE.EXECUTING_TRADE: stateSymbol = '$'; break; case NPC_STATE.MOVING_TO_WORK: stateSymbol = '<'; break; } element.dataset.stateSymbol = stateSymbol; }
} // End of Npc Class