// ======================================================
// Simple Particle System
// ======================================================
// (No changes from V4 needed)
class Particle { constructor(x, y, vx, vy, life, size, color, type = 'default', rotationSpeed = 0, height = 0) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.initialLife = life; this.life = life; this.size = size; this.color = Array.isArray(color) ? color[getRandomInt(0, color.length - 1)] : color; this.type = type; this.rotation = 0; this.rotationSpeed = rotationSpeed; this.height = height || size; } update(realDeltaTime, worldWidth, worldHeight) { this.life -= realDeltaTime; this.x += this.vx * realDeltaTime; this.y += this.vy * realDeltaTime; this.rotation += this.rotationSpeed * realDeltaTime; if (this.y > worldHeight + this.size) this.y = -this.size; if (this.y < -this.size) this.y = worldHeight + this.size; if (this.x > worldWidth + this.size) this.x = -this.size; if (this.x < -this.size) this.x = worldWidth + this.size; return this.life > 0; } draw(ctx) { const alpha = Math.max(0, this.life / this.initialLife); ctx.globalAlpha = alpha * 0.8; ctx.fillStyle = this.color; if (this.type === 'leaf') { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size); ctx.restore(); } else if (this.type === 'rain') { ctx.fillRect(this.x - this.size / 2, this.y - this.height / 2, this.size, this.height); } else { ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1.0; } }
class ParticleEmitter { constructor(worldWidth, worldHeight) { this.particles = []; this.worldWidth = worldWidth; this.worldHeight = worldHeight; this.currentType = 'none'; this.targetParticleCount = 0; this.particleConfig = null; } setType(typeKey) { if (typeKey !== this.currentType && PARTICLE_SETTINGS.types[typeKey]) { console.log(`Particle Emitter changing type to: ${typeKey}`); this.currentType = typeKey; this.particleConfig = PARTICLE_SETTINGS.types[typeKey]; this.targetParticleCount = this.particleConfig.count || 0; } } update(realDeltaTime) { this.particles = this.particles.filter(p => p.update(realDeltaTime, this.worldWidth, this.worldHeight)); if (this.particleConfig && this.particles.length < this.targetParticleCount) { const spawnRateFactor = Math.max(1, (this.targetParticleCount - this.particles.length) / 10); const particlesToSpawn = Math.min( this.targetParticleCount - this.particles.length, Math.ceil(spawnRateFactor * realDeltaTime * 5)); for (let i = 0; i < particlesToSpawn; i++) { this.spawnParticle(); } } } spawnParticle() { if (!this.particleConfig || this.particles.length >= PARTICLE_SETTINGS.maxParticles) { return; } const cfg = this.particleConfig; const x = getRandomFloat(0, this.worldWidth); const y = getRandomFloat(-20, 0); const vx = getRandomFloat(cfg.speedX.min, cfg.speedX.max); const vy = getRandomFloat(cfg.speedY.min, cfg.speedY.max); const life = getRandomFloat(cfg.life.min, cfg.life.max); const size = getRandomFloat(cfg.size.min, cfg.size.max); const rotationSpeed = cfg.rotation ? getRandomFloat(cfg.rotation.min, cfg.rotation.max) : 0; const height = cfg.height ? getRandomFloat(cfg.height.min, cfg.height.max) : 0; this.particles.push(new Particle(x, y, vx, vy, life, size, cfg.color, this.currentType, rotationSpeed, height)); } draw(ctx) { this.particles.forEach(p => p.draw(ctx)); } resize(newWidth, newHeight) { this.worldWidth = newWidth; this.worldHeight = newHeight; } }