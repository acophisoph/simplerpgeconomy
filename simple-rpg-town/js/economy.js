// ======================================================
// ECONOMY AND PRICING LOGIC
// ======================================================
// (No changes from V4 needed)
function calculateSellPrice(npc, itemId) { const basePrice = ITEMS[itemId]?.basePrice; if (basePrice === undefined) return MIN_PRICE; const occupation = npc.occupation; if (!occupation) return basePrice; const desiredStock = occupation.desiredStock?.[itemId] ?? 5; const currentStock = npc.inventory.getItemCount(itemId); const maxStockConsidered = Math.max(desiredStock * 2, npc.inventory.maxStackSize[itemId] * 1.5, desiredStock + 5); let priceMultiplier = 1.0; if (currentStock <= 0) { priceMultiplier = 1.0 + PRICE_FLUCTUATION_FACTOR * 0.5; } else if (currentStock < desiredStock) { priceMultiplier = 1.0 + PRICE_FLUCTUATION_FACTOR * (1.0 - Math.sqrt(currentStock / desiredStock)); } else { const excessRatio = Math.min(1.0, (currentStock - desiredStock) / (maxStockConsidered - desiredStock + 1)); priceMultiplier = 1.0 - PRICE_FLUCTUATION_FACTOR * 0.75 * excessRatio; } let finalPrice = Math.ceil(basePrice * priceMultiplier); if (occupation.recipes && occupation.recipes[itemId]) { let materialCost = 0; const recipe = occupation.recipes[itemId]; for (const [needId, needAmount] of Object.entries(recipe.needs)) { materialCost += (ITEMS[needId]?.basePrice || 0) * needAmount; } const costPerUnit = materialCost / (recipe.output || 1); const minProfitPrice = Math.ceil(costPerUnit * 1.1); finalPrice = Math.max(finalPrice, minProfitPrice); } return Math.max(MIN_PRICE, finalPrice); }
function calculateBuyPrice(npc, itemId) { const basePrice = ITEMS[itemId]?.basePrice; if (basePrice === undefined) return 0; const occupation = npc.occupation; if (!occupation) return 0; const usesItem = occupation.needs?.[itemId] || (occupation.recipes && Object.values(occupation.recipes).some(r => r.needs[itemId])) || (occupation.buyPrefs && occupation.buyPrefs.includes(itemId)); if (!usesItem) return 0; const desiredStock = occupation.desiredStock?.[itemId] ?? 0; const currentStock = npc.inventory.getItemCount(itemId); const maxStockWillingToBuy = Math.max(desiredStock * 1.5, npc.inventory.maxStackSize[itemId] * 1.2, desiredStock + 10); if (currentStock >= maxStockWillingToBuy && desiredStock > 0) return 0; let neededAmount = 0; let isCritical = false; if (occupation.needs?.[itemId] && ITEMS[itemId]?.durability) { neededAmount = 1; if (currentStock < 1) isCritical = true; } else if (occupation.needs?.[itemId]) { const needRate = occupation.needs[itemId]; neededAmount = Math.max(neededAmount, needRate * 5); if (currentStock < needRate) isCritical = true; } if (occupation.recipes) { Object.entries(occupation.recipes).forEach(([outputItemId, recipe]) => { if (recipe.needs[itemId]) { const outputDesired = occupation.desiredStock?.[outputItemId] || 1; const outputCurrent = npc.inventory.getItemCount(outputItemId); if (outputCurrent < outputDesired) { const recipeNeed = recipe.needs[itemId]; neededAmount = Math.max(neededAmount, recipeNeed * (outputDesired - outputCurrent)); if (currentStock < recipeNeed) isCritical = true; } } }); } if (['bread', 'meat', 'basic_potion'].includes(itemId)) { neededAmount = Math.max(neededAmount, desiredStock); if(currentStock < 1) isCritical = true; } let priceMultiplier = 0.5; if (currentStock < neededAmount) { const needFactor = 1.0 - (currentStock / (neededAmount + 0.1)); priceMultiplier = 0.5 + PRICE_FLUCTUATION_FACTOR * needFactor * (isCritical ? 1.5 : 1.0); } else if (currentStock < desiredStock) { const fillRatio = Math.max(0, (currentStock - neededAmount)) / (desiredStock - neededAmount + 1); priceMultiplier = 0.2 + 0.3 * fillRatio; } else { if (currentStock < desiredStock) { priceMultiplier = 0.1 + 0.1 * ( (desiredStock - currentStock) / (desiredStock - neededAmount + 1) ) ; } else { return 0; } } const potentialSellPrice = calculateSellPrice(npc, itemId); let buyPrice; if (!isCritical && (basePrice * priceMultiplier) >= potentialSellPrice && potentialSellPrice > MIN_PRICE) { buyPrice = Math.floor(potentialSellPrice * 0.8); } else { buyPrice = Math.floor(basePrice * priceMultiplier); } return Math.max(0, Math.min(buyPrice, npc.money)); }